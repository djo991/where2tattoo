<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Where2Tattoo — The shortest distance between you and your perfect tattoo.</title>
<meta name="description" content="Where2Tattoo connects customers with the right tattoo artist and studio.">
<meta property="og:title" content="Where2Tattoo — The shortest distance between you and your perfect tattoo.">
<meta property="og:description" content="A tiny birthday quest… and the start of something big.">
<meta property="og:type" content="website">
  <!-- FAVICONS -->
<link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon.png">
<link rel="icon" type="image/png" sizes="192x192" href="/assets/favicon.png">
<link rel="apple-touch-icon" href="/assets/favicon.png">

<!-- Social preview (OG/Twitter) -->
<meta property="og:image" content="https://where2tattoo.com/assets/favicon.png">
<meta name="twitter:card" content="summary_large_image">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  /* THEME TOKENS
   - default = dark
   - light overrides below via [data-theme="light"]
*/
:root{
  --bg:#0f1115; --bg-soft:#15161b;
  --fg:#eaeaf0; --muted:#b9b9c6;
  --line:#23242b;
  --accent:#7cf7d4; --ink:#9b8cff; /* gradient endpoints */
  --ok:#58d69c; --warn:#ffd085;
  --shadow: 0 10px 30px rgba(124,247,212,.15);
}

/* light theme overrides */
:root[data-theme="light"]{
  --bg:#f8f9fb; --bg-soft:#ffffff;
  --fg:#0f1115; --muted:#5c5f6a;
  --line:#e7e9ee;
  --shadow: 0 10px 24px rgba(123, 134, 255, .12);
}

html,body{height:100%}
body{
  margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;
  color:var(--fg);
  background:
    radial-gradient(1100px 700px at 10% -10%, rgba(255,255,255,.03) 0%, transparent 60%),
    radial-gradient(900px 600px at 90% 0%, rgba(255,255,255,.03) 0%, transparent 60%),
    var(--bg);
}

/* cards / buttons remain the same but use tokens */
.card{
  background: var(--bg-soft);                    /* solid surface */
  border: 1px solid color-mix(in oklab, var(--fg) 8%, transparent);
  border-radius: 16px;
  padding: 22px 18px;
  box-shadow: 0 1px 0 color-mix(in oklab, #000 40%, transparent); /* subtle lift */
}
.button{
  appearance:none;
  background:linear-gradient(135deg,var(--ink),var(--accent));
  color:#111; border:none; padding:12px 16px; border-radius:12px; font-weight:700;
  text-decoration:none; display:inline-flex; align-items:center; gap:10px;
  box-shadow:var(--shadow); cursor:pointer
}
.button.ghost{ border:1px solid color-mix(in oklab, var(--fg) 16%, transparent); }
.button.small{ padding:8px 12px; min-height:16px; border-radius:10px; font-weight:600; }

/* header actions */
.header-actions{ display:flex; align-items:center; gap:10px }
  header{
    display:flex;
  align-items:center;
  justify-content:space-between;
  gap:16px;

  /* sticky / style */
  position: sticky; top: 0; z-index: 50;
  backdrop-filter: blur(6px);
  background: color-mix(in oklab, var(--bg) 85%, transparent);
  border-bottom: 1px solid color-mix(in oklab, var(--fg) 6%, transparent);
  padding: 12px 20px;
  border-radius: 16px;
  margin-bottom: 18px; /* bit of breathing room under the header */
}
.theme-toggle{
  display:inline-flex; align-items:center; justify-content:center;
  width:38px; height:38px; border-radius:10px;
  background:transparent; border:1px solid var(--line); color:var(--fg);
  cursor:pointer;
}
.theme-toggle:focus-visible{outline:2px solid var(--ink); outline-offset:2px}

/* logo image if you’re using it */
.logo-img{height:36px;width:auto;display:block}
@media (min-width:900px){ .logo-img{height:44px} }

  .wrap{max-width:980px;margin:0 auto;padding:56px 20px 96px}
  .logo{display:flex;align-items:center;gap:12px;text-decoration:none;color:var(--fg)}
  .logo-badge{width:36px;height:36px;border-radius:10px;background:linear-gradient(135deg,var(--ink),var(--accent));display:grid;place-items:center;font-weight:800}
  .logo-text{font-weight:800;letter-spacing:.2px}
  .motto{margin:18px 0 0;color:var(--muted);font-size:.95rem}
  main{margin-top:40px}
  .hero{display:grid;grid-template-columns:1.1fr .9fr;gap:28px}
  @media (max-width:900px){ .hero{grid-template-columns:1fr } }
  h1{font-size:clamp(1.9rem,3.5vw,2.8rem);line-height:1.08;margin:.2em 0}
  .sub{color:var(--muted);font-size:1.05rem}
  .bullets{display:grid;gap:10px;margin:12px 0 4px}
  .bullets b{color:var(--fg)}
  .puzzle{margin-top:18px;display:flex;gap:10px;flex-wrap:wrap}
  .puzzle input{background:var(--bg);border:1px solid var(--line);color:var(--fg);padding:12px 14px;border-radius:12px;min-width:220px;letter-spacing:.2em;text-transform:uppercase}
  .msg{margin-top:12px;color:var(--muted)}
  .reveal{display:none;margin-top:16px}
  .success{color:var(--ok);font-weight:700}
  .hint{color:var(--warn)}
  .grid{display:grid;grid-template-columns:1fr;gap:16px;margin-top:24px}
  footer{
  margin-top: 48px;
  padding: 18px 0 32px;
  border-top: 1px solid color-mix(in oklab, var(--fg) 6%, transparent);
  color: var(--muted);
  font-size: .9rem;
}
  .needle{border-bottom:1px dotted var(--line);cursor:help}
  :focus-visible{
  outline: 2px solid var(--ink);
  outline-offset: 2px;
  border-radius: 10px;
}
 /* ===== PANZER MINI-GAME ===== */
#gameOverlay{
  position:fixed; inset:0; z-index:9999;
  display:grid !important; place-items:center;
  background:color-mix(in oklab,var(--bg) 55%,transparent); backdrop-filter:blur(2px);
}
#gameWrap{
  position:relative; width:min(980px,92vw); height:min(70vh,620px);
  background:var(--bg-soft);
  border:1px solid color-mix(in oklab,var(--fg) 10%,transparent);
  border-radius:16px; box-shadow:0 20px 60px rgba(0,0,0,.35);
  overflow:hidden;
}
#gameCanvas{ position:absolute; inset:0; width:100%; height:100% }

#gameHud{
  position:absolute; top:10px; left:12px; right:88px;  /* leave gutter for ✕ */
  display:flex; gap:8px; align-items:center; z-index:3;
}
#gameHud .pill{
  background:color-mix(in oklab,var(--fg) 6%,transparent);
  border:1px solid color-mix(in oklab,var(--fg) 14%,transparent);
  padding:6px 10px; border-radius:999px; font-weight:600;
  display:inline-flex; align-items:center; gap:8px;
}

/* top-right close button */
#closeGame{
  position:absolute; top:8px; right:8px; width:40px; height:40px;
  border-radius:10px;
  border:1px solid color-mix(in oklab,var(--fg) 12%,transparent);
  background:var(--bg); color:var(--fg); font-weight:800; z-index:4; cursor:pointer;
}
#closeGame:hover{ background:color-mix(in oklab,var(--fg) 6%,var(--bg)) }

/* on-screen d-pad (always grid; never switches to flex) */
/* D-pad visibility: hide by default, show on touch devices */
#gameDpad{ display:none; }  /* override the base rule */

@media (pointer: coarse), (hover: none) {
  #gameDpad{ display:grid; }
}
#gameDpad button{
  width:48px; height:48px; border-radius:12px;
  border:1px solid color-mix(in oklab,var(--fg) 16%,transparent);
  background:color-mix(in oklab,var(--fg) 6%,transparent);
  color:var(--fg); font-weight:700;
  pointer-events:auto;
}
#gameDpad .up{grid-area:up;} .left{grid-area:left;} .right{grid-area:right;} .down{grid-area:down;}

</style>
</head>
<body>
<div class="wrap">

  <header>
    <a class="logo" href="/">
  <img class="logo-img" src="/assets/logo.png" alt="Where2Tattoo logo">
  <div>
    <div class="logo-text">Where2Tattoo</div>
    <div class="motto">The shortest distance between you and your perfect tattoo.</div>
  </div>
</a>
   <nav class="header-actions">
  <a class="button small" href="mailto:abatklaudija@gmail.com?subject=Where2Tattoo">Email</a>
  <a class="button small ghost" href="mailto:abatklaudija@gmail.com?subject=Where2Tattoo%20Artist%20Waitlist">Artist waitlist</a>
  <button id="themeToggle" class="theme-toggle" aria-label="Toggle theme" title="Toggle theme">🌙</button>
</nav>
  </header>

  <main class="hero">
    <section class="card">
      <h1>Happy Birthday<span id="nameSlot"></span>! 🎉</h1>
      <p class="sub">
        We left these breadcrumbs because we believe in the thing you’ll build.<br>
        You’ve followed the trail, read the signs, and found the door.
      </p>

      <div class="puzzle">
        <input id="code" maxlength="8" placeholder="Enter code ( _ _ _ )" aria-label="Puzzle code">
        <button class="button" id="unlock">Unlock</button>
        <button class="button ghost" id="hintBtn">Need a hint?</button>
      </div>
      <div class="msg" id="msg" role="status">
        Type the code and press <b>Unlock</b>. </br><small>(Pro tip: you can also try Raiden’s Electric Fly — it might not solve anything, but it’s fun! Or you could try the unstoppable catterpillar of GTA Vice City.)</small>
      </div>

      <div class="reveal" id="reveal">
        <p class="success">✔ Unlocked!</p>
        <p>
          You’ve come this far using your wits - now use them to make this real. Start small: one city, ten artists, a waitlist.
          Talk to people before pixels. Update weekly.
          We believe in you. This is your canvas.
        </p>
        <div class="puzzle">
          <a class="button" id="giftLink" href="#" target="_blank" rel="noopener">Claim your gift</a>
          <a class="button ghost" href="mailto:abatklaudija@gmail.com?subject=Where2Tattoo%20Kickoff&body=Let%E2%80%99s%20ship%20it.">Let’s ship it</a>
        </div>
      </div>
    </section>

    <aside class="card">
      <h3 style="margin-top:0">What is Where2Tattoo?</h3>
      <div class="bullets">
        <div><b>For customers:</b> tell us the style, budget, and timing—get matched to the right artist, not just the nearest one.</div>
        <div><b>For artists:</b> a steady stream of briefs with reference boards and intent—no more cold DMs.</div>
        <div><b>For studios:</b> calendar fills + deposit handling + aftercare nudges that bring people back.</div>
      </div>
      <div class="grid">
        <div class="card"><b>Match smarter</b><br><span class="muted">Style tags, healed-work ratings, and real waitlists.</span></div>
        <div class="card"><b>Trust by design</b><br><span class="muted">Verified portfolios, deposits, simple reschedules.</span></div>
        <div class="card"><b>Local first</b><br><span class="muted">City-level discovery with travel-artist drops.</span></div>
      </div>
    </aside>
  </main>

  <section class="card" style="margin-top:24px">
    <h3 style="margin-top:0">A note from your co-conspirators</h3>
    <p>
      When in doubt, ask what removes friction for artists and what builds confidence for clients. Do that twice. Then do it again.
      We’re proud of you—and yes, we bought two domains. Consider it a nudge.
    </p>
  </section>

  <footer>
    © <span id="year"></span> Where2Tattoo • Built with love and <span class="needle" title="Needle #3">ink</span>.
  </footer>
</div>

<script>
  // ——— Settings you can tweak ———
  const SECRET_CODE = "INK";                 // puzzle answer (uppercase)
  const SHOW_NAME = "Marko";                 // put your brother's name or leave empty
  const PANZER_CODE = "PANZER"
  const GIFT_URL = "https://drive.google.com/file/d/1WwiMPd_vuV63-vZd_YKrkOYO5AIeQuY7/view?usp=drive_link";

//Theme switch

  // THEME TOGGLE — respects system preference first time, then remembers choice
  (function () {
    const btn = document.getElementById('themeToggle'); // define first

    function setTheme(t) {
      document.documentElement.setAttribute('data-theme', t);
      const isLight = t === 'light';
      if (btn) { // guard in case button isn't present yet
        btn.textContent = isLight ? '☀️' : '🌙';
        btn.setAttribute('aria-label', isLight ? 'Switch to dark theme' : 'Switch to light theme');
      }
    }

    const saved = localStorage.getItem('w2t-theme');
    const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
    const theme = saved || (prefersLight ? 'light' : 'dark');
    setTheme(theme);

    if (btn) {
      btn.addEventListener('click', () => {
        const next = (document.documentElement.getAttribute('data-theme') === 'light') ? 'dark' : 'light';
        setTheme(next);
        localStorage.setItem('w2t-theme', next);
      });
    }
  })();

  
  // ——— Basic UI wiring ———  
  document.getElementById("year").textContent = new Date().getFullYear();
  if (SHOW_NAME) document.getElementById("nameSlot").textContent = ", " + SHOW_NAME;
  document.getElementById("giftLink").setAttribute("href", GIFT_URL);

  const input = document.getElementById("code");
  const btn = document.getElementById("unlock");
  const msg = document.getElementById("msg");
  const reveal = document.getElementById("reveal");
  const hintBtn = document.getElementById("hintBtn");

  function unlock() {
  const val = (input.value || "").trim().toUpperCase();

  if (val === PANZER_CODE){
    input.value = "";
    msg.innerHTML = '🎯 Bonus unlocked: <b>PANZER</b> mini-game!';
    startPanzer();
    return;
  }

  if (!val) { msg.textContent = "Try a three-letter word artists can’t work without."; return; }

  if (val === SECRET_CODE) {
    reveal.style.display = "block";
    msg.innerHTML = '<span class="success">Nice.</span> Welcome inside.';
    confettiBurst();                      // ← bring back confetti!
  } else {
    msg.innerHTML = 'Not quite. Think fluid. Think permanent. Think <span class="needle" title="It rhymes with *pink*">color carrier</span>.';
  }
}
  btn.addEventListener("click", unlock);
  input.addEventListener("keydown", (e)=>{ if(e.key==="Enter") unlock(); });
  hintBtn.addEventListener("click", ()=>{ msg.innerHTML = '<span class="hint">Hint:</span> The machine drinks it; the skin remembers it.' });

  // ——— WebAudio: thunder (first keypress unlocks AudioContext) ———
  let audioCtx = null, masterGain = null, comp = null;
  function ensureAudio(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    comp = audioCtx.createDynamicsCompressor();
    comp.threshold.value = -18; comp.knee.value = 20; comp.ratio.value = 3; comp.attack.value = 0.003; comp.release.value = 0.25;
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.7; // overall loudness
    comp.connect(masterGain).connect(audioCtx.destination);
  }
  window.addEventListener("keydown", ensureAudio, { once:true });

  function thunderAudio(){
    if (!audioCtx) return;
    const now = audioCtx.currentTime;

    // Randomized "distance": farther = longer delay + softer rumble
    const distance = Math.random();                           // 0..1
    const crackToRumbleDelay = 0.08 + distance * 0.35;        // 80–430ms
    const rumbleDur = 1.2 + distance * 1.6;                   // 1.2–2.8s
    const rumbleGain = 0.5 - distance * 0.25;                 // 0.5→0.25

    // 1) Lightning CRACK — bright, very short band-passed noise + tiny click
    const crackBuf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*0.09), audioCtx.sampleRate);
    const cd = crackBuf.getChannelData(0);
    for (let i=0;i<cd.length;i++){ cd[i] = (Math.random()*2-1) * (1 - i/cd.length); }
    const crack = audioCtx.createBufferSource(); crack.buffer = crackBuf;
    const crackBP = audioCtx.createBiquadFilter(); crackBP.type = "bandpass"; crackBP.frequency.value = 3500; crackBP.Q.value = 2.5;
    const crackHP = audioCtx.createBiquadFilter(); crackHP.type = "highpass"; crackHP.frequency.value = 600; crackHP.Q.value = 0.7;
    const crackG = audioCtx.createGain(); crackG.gain.setValueAtTime(0.0, now);
    crackG.gain.linearRampToValueAtTime(1.0, now + 0.01);
    crackG.gain.exponentialRampToValueAtTime(0.02, now + 0.09);
    crack.connect(crackBP).connect(crackHP).connect(crackG).connect(comp);
    crack.start(now); crack.stop(now+0.1);

    // 2) RUMBLE — low-passed noise, light stereo spread
    // build noise buffer for rumble
    const rLen = Math.floor(audioCtx.sampleRate * rumbleDur);
    const rBuf = audioCtx.createBuffer(1, rLen, audioCtx.sampleRate);
    const rd = rBuf.getChannelData(0);
    // "pink-ish": integrate white a bit
    let accum = 0;
    for (let i=0;i<rLen;i++){
      const w = Math.random()*2-1;
      accum = accum*0.98 + w*0.02;                  // simple low-frequency emphasis
      rd[i] = accum * (1 - i/rLen);                 // fade out over time
    }
    const rumble = audioCtx.createBufferSource(); rumble.buffer = rBuf;
    const lp = audioCtx.createBiquadFilter(); lp.type = "lowpass"; lp.frequency.value = 180; lp.Q.value = 0.5;
    const rumbleL = audioCtx.createGain(), rumbleR = audioCtx.createGain();
    rumbleL.gain.value = rumbleGain, rumbleR.gain.value = rumbleGain * 0.92;

    const splitter = audioCtx.createChannelSplitter(2);
    const merger = audioCtx.createChannelMerger(2);
    const dly = audioCtx.createDelay(); dly.delayTime.value = 0.015 + Math.random()*0.02; // tiny offset right ear

    // route mono rumble to stereo with slight delay on R
    rumble.connect(lp);
    lp.connect(rumbleL);
    lp.connect(dly);
    dly.connect(rumbleR);

    const panL = audioCtx.createStereoPanner(); panL.pan.value = -0.15 + Math.random()*-0.15;
    const panR = audioCtx.createStereoPanner(); panR.pan.value = 0.15 + Math.random()*0.15;
    rumbleL.connect(panL).connect(comp);
    rumbleR.connect(panR).connect(comp);

    // gentle fade curve
    const startR = now + crackToRumbleDelay;
    rumbleL.gain.setValueAtTime(0.001, startR);
    rumbleL.gain.exponentialRampToValueAtTime(rumbleGain, startR + 0.15);
    rumbleL.gain.exponentialRampToValueAtTime(0.001, startR + rumbleDur);

    rumbleR.gain.setValueAtTime(0.001, startR);
    rumbleR.gain.exponentialRampToValueAtTime(rumbleGain*0.92, startR + 0.15);
    rumbleR.gain.exponentialRampToValueAtTime(0.001, startR + rumbleDur);

    rumble.start(startR); rumble.stop(startR + rumbleDur);

    // 3) SUB-BASS BOOM with slight pitch drop (distance-scaled)
    const sub = audioCtx.createOscillator(); sub.type = "sine";
    const subGain = audioCtx.createGain();
    const subStart = startR + 0.05;
    const startFreq = 60 - distance*10, endFreq = 30 - distance*5;
    sub.frequency.setValueAtTime(startFreq, subStart);
    sub.frequency.exponentialRampToValueAtTime(Math.max(20,endFreq), subStart + 0.9 + distance*0.5);
    subGain.gain.setValueAtTime(0.0001, subStart);
    subGain.gain.exponentialRampToValueAtTime(0.3*(0.9-distance*0.6), subStart + 0.06);
    subGain.gain.exponentialRampToValueAtTime(0.0001, subStart + 1.2 + distance*0.6);
    sub.connect(subGain).connect(comp);
    sub.start(subStart);
    sub.stop(subStart + 1.3 + distance*0.6);
  }

  // ——— Raiden's Electric Fly (←, ←, →) → lightning + thunder (repeatable) ———
  const RAIDENTRIC = ["ArrowLeft","ArrowLeft","ArrowRight"];
  let seq = [];
  window.addEventListener("keydown", e=>{
    seq.push(e.key);
    if (seq.length > RAIDENTRIC.length) seq.shift();
    if (RAIDENTRIC.every((k,i)=>seq[i]===k)) {
      strikeLightning();               // visuals
      thunderAudio();                  // BIG sound
      msg.innerHTML = '⚡ Nice, but now solve the riddle!';
    }
  });

  // ——— Lightning effect: create canvas on demand, randomize, remove when done ———
  let cvs = null, ctx = null, strikes = [], animating = false, fadeTimer = null;

  function ensureCanvas(){
    if (cvs) return;
    cvs = document.createElement('canvas');
    cvs.id = 'fx';
    Object.assign(cvs.style, {position:'fixed', inset:'0', pointerEvents:'none', opacity:'0.95'});
    document.body.appendChild(cvs);
    ctx = cvs.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
  }
  function removeCanvas(){
    if (!cvs) return;
    window.removeEventListener('resize', resize);
    cvs.remove(); cvs = null; ctx = null;
  }
  function resize(){ if (cvs){ cvs.width = innerWidth; cvs.height = innerHeight; } }

  function strikeLightning() {
    ensureCanvas();
    const boltCount = 2 + Math.floor(Math.random()*3); // 2–4 bolts per trigger
    const STRIKE_MS = 500 + Math.random()*500;

    for (let b=0;b<boltCount;b++){
      const startX = Math.random()*cvs.width;            // random across sky
      const endY = cvs.height*(0.4 + Math.random()*0.5); // random depth
      const segs = 8 + Math.floor(Math.random()*6);
      const pts = [];
      let px = startX, py = -20;
      for (let i=1;i<=segs;i++){
        const ny = -20 + (endY + 20) * (i/segs);
        const spread = 70 + (i*8); // wider as it falls
        const nx = px + (Math.random()*spread - spread/2);
        pts.push([nx, ny]); px = nx; py = ny;
      }
      strikes.push({ born: performance.now(), life: STRIKE_MS, pts, branch: Math.random()<0.7 });
    }
    if (!animating) animate();
  }

  function animate() {
    animating = true;
    const now = performance.now();

    // semi-clear with dark overlay for afterglow
    ctx.fillStyle = "rgba(0,0,0,0.30)";
    ctx.fillRect(0,0,cvs.width,cvs.height);

    for (let i = strikes.length - 1; i >= 0; i--) {
      const s = strikes[i];
      const t = now - s.born;
      const p = Math.min(1, t / s.life);
      const alpha = (1 - p) * 0.95 + 0.05;

      // quick flash at start
      if (t < 110) {
        ctx.fillStyle = `rgba(255,255,255,${0.18 * (1 - t/110)})`;
        ctx.fillRect(0,0,cvs.width,cvs.height);
      }

      ctx.lineWidth = 2.2;
      ctx.shadowBlur = 16;
      ctx.shadowColor = "rgba(255,255,255,0.9)";
      ctx.strokeStyle = `rgba(255,255,255,${alpha})`;

      ctx.beginPath();
      ctx.moveTo(s.pts[0][0], -10);
      for (let j=0;j<s.pts.length;j++){
        const [bx, by] = s.pts[j];
        ctx.lineTo(bx + (Math.random()-0.5)*4, by + (Math.random()-0.5)*4);
        if (s.branch && Math.random()<0.18){
          ctx.moveTo(bx,by);
          ctx.lineTo(bx + (Math.random()*60-30), by + (Math.random()*60));
          ctx.moveTo(bx,by);
        }
      }
      ctx.stroke();

      if (t > s.life) strikes.splice(i, 1);
    }

    if (strikes.length) {
      requestAnimationFrame(animate);
      if (fadeTimer){ clearTimeout(fadeTimer); fadeTimer = null; }
    } else {
      if (!fadeTimer){
        fadeTimer = setTimeout(()=>{
          if (!cvs) return;
          ctx.fillStyle = "rgba(0,0,0,0.5)";
          ctx.fillRect(0,0,cvs.width,cvs.height);
          removeCanvas();
          animating = false;
          fadeTimer = null;
        }, 200);
      }
    }
  }

  function confettiBurst(opts = {}) {
  const { count = 160, duration = 2400 } = opts;
  if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

  // kill any old confetti
  if (window.__confettiRAF) cancelAnimationFrame(window.__confettiRAF);
  if (window.__confettiCanvas) window.__confettiCanvas.remove();

  const cvs = document.createElement('canvas');
  Object.assign(cvs.style, {
    position:'fixed', inset:'0', pointerEvents:'none', zIndex:'9998', opacity:'0.95'
  });
  document.body.appendChild(cvs);
  window.__confettiCanvas = cvs;

  const ctx = cvs.getContext('2d');
  function resize(){ cvs.width = innerWidth; cvs.height = innerHeight; }
  addEventListener('resize', resize); resize();

  const cs = getComputedStyle(document.documentElement);
  const c1 = cs.getPropertyValue('--accent').trim() || '#7cf7d4';
  const c2 = cs.getPropertyValue('--ink').trim()    || '#9b8cff';
  const colors = [c1, c2, '#ffffff'];

  let bits = Array.from({length: count}, () => ({
    x: Math.random()*cvs.width,
    y: -20 - Math.random()*cvs.height*0.3,
    r: 4 + Math.random()*4,
    vx: -2 + Math.random()*4,
    vy: 2 + Math.random()*3,
    a: Math.random()*Math.PI*2,
    va: -0.12 + Math.random()*0.24,
    color: colors[Math.floor(Math.random()*colors.length)]
  }));

  const born = performance.now();

  function tick(){
    ctx.clearRect(0,0,cvs.width,cvs.height);
    for (const b of bits){
      b.x += b.vx; b.y += b.vy; b.a += b.va; b.vy += 0.03;
      ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.a);
      ctx.fillStyle = b.color; ctx.fillRect(-b.r/2,-b.r/2,b.r,b.r);
      ctx.restore();
    }
    bits = bits.filter(b => b.y < cvs.height+24);
    window.__confettiRAF = requestAnimationFrame(tick);

    const age = performance.now() - born;
    if (age > duration) bits.length = 0;                // start clearing
    if (!bits.length) {
      cancelAnimationFrame(window.__confettiRAF);
      removeEventListener('resize', resize);
      cvs.remove(); window.__confettiCanvas = null;
      window.__confettiRAF = null;
    }
  }
  tick();
}

/* ===== PANZER MINI-GAME (full-bleed grid, anisotropic scale) ===== */
(function(){
  const REDUCE_MOTION = matchMedia && matchMedia('(prefers-reduced-motion: reduce)').matches;

  let overlay=null, wrap=null, cvs=null, ctx=null, dpad=null;

  // Grid
  const COLS=11, ROWS=12, CELL=48;      // CELL is just a logical baseline
  let W=COLS*CELL, H=ROWS*CELL;
  let cellW=48, cellH=48, prevCellW=48;

  // Player/state
  const START_POS = { x: Math.floor(COLS/2), y: ROWS-1 };
  let difficulty = 1;                 // current multiplier
  const DIFFICULTY_STEP = 1.30;       // +10% each win
  let px, py, lives, t0, timeNow, running=false, raf=null, lastTime=0;

  // Lanes/cars
  const lanes=[];

  function palette(){
    const light = document.documentElement.getAttribute('data-theme') === 'light';
    return light ? {
      asphalt:'#e9edf5', asphaltAlt:'#f5f7fb', lane:'#b8c1d0', safe:'#ffffff', finish:'#b0c0d4',
      carA:'#2b59ff', carB:'#00b8a9', outline:'#2a2f36', tankHull:'#2b59ff', tankTurret:'#00b8a9',
      highlight:'rgba(0,184,169,.18)'
    } : {
      asphalt:'#141922', asphaltAlt:'#1a2030', lane:'#65708a', safe:'#0e131a', finish:'#8aa0bf',
      carA:'#7cf7d4', carB:'#9b8cff', outline:'#000000', tankHull:'#7cf7d4', tankTurret:'#9b8cff',
      highlight:'rgba(124,247,212,.16)'
    };
  }

  function buildLanes(){
    lanes.length=0;
    [
      {row:9, dir: 1, speed:2.8, density:.22},
      {row:8, dir:-1, speed:3.6, density:.25},
      {row:7, dir: 1, speed:2.2, density:.20},
      {row:6, dir:-1, speed:4.0, density:.28},
      {row:5, dir: 1, speed:3.2, density:.22},
      {row:4, dir:-1, speed:2.6, density:.20},
      {row:3, dir: 1, speed:3.8, density:.28},
      {row:2, dir:-1, speed:2.4, density:.22},
    ].forEach(s => lanes.push({...s, cars:[]}));
  }

  // Cars are stored in canvas pixels (x,w). Use cellW so they scale with width.
  function spawnCars(){
  lanes.forEach(l=>{
    l.cars.length = 0;
    const count = Math.max(3, Math.round(COLS * l.density));   // at least 3 per lane
    const gap = W / count;                                     // spread across canvas width
    for (let i = 0; i < count; i++){
      const w = (1.4 + Math.random()*1.1) * cellW;             // ~1.4–2.5 cells wide
      const jitter = (Math.random()*0.6 - 0.3) * gap;          // -30%..+30% of gap
      const x = i * gap + jitter - w/2;                        // centered in its slot
      l.cars.push({ x, w });
    }
  });
}
  function purgeOldOverlays(){
    document.querySelectorAll('#gameOverlay').forEach(el=>el.remove());
  }

  function ensureOverlay(){
    if (overlay) return;
    overlay = document.createElement('div');
    overlay.id = 'gameOverlay';
    overlay.innerHTML = `
      <div id="gameWrap">
        <button id="closeGame" aria-label="Close game">✕</button>
        <div id="gameHud">
          <div class="pill">⏱ <span id="hudTime">0.0</span>s • ❤️ <span id="hudLives">3</span></div>
          <button class="pill" id="btnRestart">⟳ Restart</button>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="gameDpad" aria-hidden="false">
          <button class="up"    data-dx="0"  data-dy="-1">↑</button>
          <button class="left"  data-dx="-1" data-dy="0">←</button>
          <button class="right" data-dx="1"  data-dy="0">→</button>
          <button class="down"  data-dx="0"  data-dy="1">↓</button>
        </div>
      </div>`;
    document.body.appendChild(overlay);

    wrap = overlay.querySelector('#gameWrap');
    cvs  = overlay.querySelector('#gameCanvas');
    ctx  = cvs.getContext('2d', { alpha:false });
    dpad = overlay.querySelector('#gameDpad');

    overlay.querySelector('#closeGame').addEventListener('click', stopPanzer);
    overlay.querySelector('#btnRestart').addEventListener('click', resetGame);
    dpad.querySelectorAll('button').forEach(b=>{
      b.addEventListener('click', ()=> movePlayer(+b.dataset.dx, +b.dataset.dy));
    });
    const isTouch = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) || 'ontouchstart' in window;
dpad.style.display = isTouch ? 'grid' : 'none';
dpad.setAttribute('aria-hidden', isTouch ? 'false' : 'true');
    addEventListener('resize', resizeCanvas);
    resizeCanvas();
  }
  function removeOverlay(){
    if (!overlay) return;
    removeEventListener('resize', resizeCanvas);
    overlay.remove(); overlay=null; wrap=cvs=ctx=dpad=null;
  }

  window.startPanzer = function(){
    purgeOldOverlays();
    ensureOverlay();
    overlay.style.display = 'grid';
     difficulty = 1;
    begin();
  };

  function stopPanzer(){
    running=false;
    if (raf) cancelAnimationFrame(raf);
    removeEventListener('keydown', onKey);
    removeOverlay();
  }

  // --- geometry helpers (full canvas -> grid cells) ---
  function resizeCanvas(){
    const r=wrap.getBoundingClientRect();
    W=r.width; H=r.height;
    const newCellW = W / COLS;
    const factor = newCellW / (cellW || newCellW);
    prevCellW = cellW || newCellW;
    cellW = newCellW;
    cellH = H / ROWS;
    // keep cars visually in place when width changes
    lanes.forEach(l => l.cars.forEach(c => { c.x *= factor; c.w *= factor; }));
    cvs.width=W; cvs.height=H;
  }
  const colX = c => c * cellW;
  const rowY = r => r * cellH;
  const rowH = n => n * cellH;
  const rect = (x,y,w,h)=> ctx.fillRect(x,y,w,h);
  function line(x1,y1,x2,y2){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
  function roundRect(x,y,w,h,r,fill){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); fill?ctx.fill():ctx.stroke(); }
  const clamp = (v,min,max)=> v<min?min:(v>max?max:v);
  const rectsOverlap = (ax,ay,aw,ah,bx,by,bw,bh)=> ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;

  function drawRoad(){
    const p=palette();
    // full-bleed road drawn across W/H
    ctx.fillStyle=p.safe;   rect(0, rowY(0), W, rowH(2));
                            rect(0, rowY(ROWS-2), W, rowH(2));
    ctx.fillStyle=p.asphalt; rect(0, rowY(2), W, rowH(ROWS-4));
    for(let r=2;r<ROWS-2;r++){ if(r%2===1){ ctx.fillStyle=p.asphaltAlt; rect(0,rowY(r),W,rowH(1)); } }
    ctx.strokeStyle=p.lane; ctx.setLineDash([12,12]); ctx.lineWidth=2;
    for(let r=2;r<ROWS-2;r++){ const y=rowY(r)+rowH(1)/2; line(0,y,W,y); }
    ctx.setLineDash([]);
    ctx.fillStyle=p.finish; rect(0, rowY(2)-rowH(.15), W, rowH(.15));
  }
  function drawTank(x,y){
    const p=palette(), sX=cellW, sY=cellH, gx=colX(x), gy=rowY(y);
    ctx.fillStyle=p.highlight; roundRect(gx+sX*.06, gy+sY*.06, sX*.88, sY*.88, 10, true);
    ctx.strokeStyle='rgba(255,255,255,.6)'; ctx.lineWidth=1.5; roundRect(gx+sX*.06, gy+sY*.06, sX*.88, sY*.88, 10, false);
    ctx.fillStyle='rgba(0,0,0,.7)'; roundRect(gx+sX*.10, gy+sY*.18, sX*.80, sY*.14, 6, true); roundRect(gx+sX*.10, gy+sY*.68, sX*.80, sY*.14, 6, true);
    ctx.fillStyle=p.tankHull;   roundRect(gx+sX*.18, gy+sY*.30, sX*.64, sY*.40, 8, true);
    ctx.fillStyle=p.tankTurret; roundRect(gx+sX*.40, gy+sY*.38, sX*.26, sY*.24, 6, true); ctx.fillRect(gx+sX*.66, gy+sY*.46, sX*.32, sY*.08);
  }
  function drawCar(lane, car){
  const p = palette();
  const x = car.x;
  const y = rowY(lane.row) + cellH * 0.12;
  const h = cellH * 0.76;

  ctx.save();
  ctx.shadowBlur = 10;
  ctx.shadowColor = 'rgba(255,255,255,.25)';
  ctx.fillStyle = lane.dir > 0 ? p.carA : p.carB;              // two colors by lane direction
  roundRect(x, y, car.w, h, 10, true);                         // fill
  ctx.restore();

  ctx.strokeStyle = p.outline;                                  // thin outline like before
  ctx.lineWidth = 2;
  roundRect(x, y, car.w, h, 10, false);
}

  function onKey(e){
    if(!running) return;
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(e.key)) e.preventDefault();
    if(e.key==='Escape'){ stopPanzer(); return; }
    const map={ArrowUp:[0,-1],ArrowDown:[0,1],ArrowLeft:[-1,0],ArrowRight:[1,0],w:[0,-1],s:[0,1],a:[-1,0],d:[1,0],W:[0,-1],S:[0,1],A:[-1,0],D:[1,0]};
    if(map[e.key]) movePlayer(map[e.key][0], map[e.key][1]);
  }
  function movePlayer(dx,dy){
    px = clamp(px+dx, 0, COLS-1);
    py = clamp(py+dy, 0, ROWS-1);
    if(py<=1) gameOver(true);
  }

  function sfx(kind){
    if (!audioCtx || REDUCE_MOTION) return;
    const t=audioCtx.currentTime;
    if(kind==='boom'){ const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type='sawtooth'; o.frequency.setValueAtTime(120,t); o.frequency.exponentialRampToValueAtTime(40,t+0.4);
      g.gain.setValueAtTime(0.2,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.45);
      o.connect(g).connect(audioCtx.destination); o.start(t); o.stop(t+0.5);
    } else if(kind==='win'){ const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type='triangle'; o.frequency.setValueAtTime(520,t); o.frequency.setValueAtTime(660,t+0.12); o.frequency.setValueAtTime(880,t+0.26);
      g.gain.setValueAtTime(0.12,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.6);
      o.connect(g).connect(audioCtx.destination); o.start(t); o.stop(t+0.65);
    }
  }

  function begin(){
    buildLanes();
    resizeCanvas();            // compute cellW/cellH first
    spawnCars();

    px=START_POS.x; py=START_POS.y; lives=3; t0=performance.now(); timeNow=0;
    addEventListener('keydown', onKey);
    running=true; lastTime=performance.now(); tick();
  }
  function resetGame(){
    px=START_POS.x; py=START_POS.y; lives=3; t0=performance.now(); spawnCars();
  }

  function tick(){
    if(!running) return;
    raf=requestAnimationFrame(tick);
    const now=performance.now(), dt=Math.min(32, now-lastTime)/1000; lastTime=now;
    timeNow=(now-t0)/1000;

    // Move + wrap using full width W
    lanes.forEach(l=>{
      const v = l.speed * cellW * l.dir * difficulty;
  const off = 2 * cellW;                   // wrap buffer
  l.cars.forEach(c=>{
    c.x += v * dt;
    if (l.dir > 0 && c.x > W + off)   c.x = -c.w - off;
    if (l.dir < 0 && c.x < -c.w - off) c.x = W + off;
  });
});

    // Collisions (rows 2..9)
    if(py>=2 && py<=9){
      const lane = lanes.find(L => L.row === py);
      if(lane){
        const pxPix=colX(px)+cellW*.15, pwPix=cellW*.70;
        const pyPix=rowY(py)+cellH*.10, phPix=cellH*.80;
        for(const c of lane.cars){
          if(rectsOverlap(pxPix,pyPix,pwPix,phPix, c.x, rowY(py)+cellH*.12, c.w, cellH*.76)){
            lives--; sfx('boom'); px=START_POS.x; py=START_POS.y;
            if(lives<=0){ gameOver(false); return; }
            break;
          }
        }
      }
    }

    drawScene(); updateHud();
  }

  function drawScene(){
    ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--bg');
    ctx.fillRect(0,0,W,H);
    drawRoad();
    lanes.forEach(l=>l.cars.forEach(c=>drawCar(l,c)));
    drawTank(px,py);

    // Goal banner (fixed rgba to avoid color-mix() oddities in canvas)
    ctx.fillStyle='rgba(124,247,212,0.18)'; rect(0, rowY(0), W, rowH(1));
    ctx.fillStyle='rgba(255,255,255,0.35)'; ctx.font=`${14*(cellH/48)}px Inter, system-ui, sans-serif`;
    ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('Goal', W/2, rowY(0)+rowH(.5));
  }
  function updateHud(){
    overlay.querySelector('#hudTime').textContent=timeNow.toFixed(1);
    overlay.querySelector('#hudLives').textContent=lives;
  }

  function gameOver(win){
    running=false; if(raf) cancelAnimationFrame(raf); sfx(win?'win':'boom');
    if (win) difficulty *= DIFFICULTY_STEP;
    const banner=document.createElement('div');
    Object.assign(banner.style,{position:'absolute',inset:'0',display:'grid',placeItems:'center',
      background:'rgba(0,0,0,.45)', color:'var(--fg)', fontWeight:'800',
      fontSize:'clamp(20px,3.6vw,32px)', zIndex:5});
    banner.innerHTML=`
      <div class="card" style="padding:18px 16px; text-align:center; max-width:420px">
        <div style="font-size:1.1em; margin-bottom:4px">${win?'✅ Mission complete!':'💥 W A S T E D 💥'}</div>
        <div style="font-weight:600;font-size:.8em;margin:.3em 0 .8em;opacity:.85">Time: ${timeNow.toFixed(1)}s</div>
        <div style="display:flex; gap:10px; justify-content:center">
          <button id="again" class="button small">⟳ Play again</button>
          <button id="close" class="button small ghost">✕ Close</button>
        </div>
      </div>`;
    wrap.appendChild(banner);
    banner.querySelector('#again').addEventListener('click', ()=>{ banner.remove(); resetGame(); running=true; lastTime=performance.now(); tick(); });
    banner.querySelector('#close').addEventListener('click', ()=>{ banner.remove(); stopPanzer(); });
  }
})();

</script>
</body>
</html>
